Regular Expressions

Regular expressions in Python use the 're' module


use them like this:

  match = re.search(pat, str)

where pat is the pattern to search for, and str is the string to search


 - if a match is found, the matched object is returned
 - otherwise, the search function returns None


Pairing with If Statements:

  - regex are most often paired with if statements, like so:

    str = 'an example word:cat!!'
    match = re.search(r'word:\w\w\w', str)
    # If-statement after search() tests if it succeeded
    if match:
      print 'found', match.group() ## 'found word:cat'
    else:
      print 'did not find'

  - the 'r' at the start of the pattern signifies a python 'raw' string
  - raw strings pass through backslashes without change
  - recommended to always write pattern strings with the 'r'



  Basic Patterns

  The power of regular expressions is that they can specify patterns, not just fixed characters. Here are the most basic patterns which match single chars:

    - a, X, 9, < -- ordinary characters just match themselves exactly. The meta-characters which do not match themselves because they have special meanings are: . ^ $ * + ? { [ ] \ | ( ) (details below)

    - . (a period) -- matches any single character except newline '\n'

    - \w -- (lowercase w) matches a "word" character: a letter or digit or underbar [a-zA-Z0-9_]. Note that although "word" is the mnemonic for this, it only matches a single word char, not a whole word. \W (upper case W) matches any non-word character.

    - \b -- boundary between word and non-word

    - \s -- (lowercase s) matches a single whitespace character -- space, newline, return, tab, form [ \n\r\t\f]. \S (upper case S) matches any non-whitespace character.

    - \t, \n, \r -- tab, newline, return

    - \d -- decimal digit [0-9] (some older regex utilities do not support but \d, but they all support \w and \s)

    - ^ = start, $ = end -- match the start or end of the string

    - \ -- inhibit the "specialness" of a character. So, for example, use \. to match a period or \\ to match a slash. If you are unsure if a character has special meaning, such as '@', you can put a slash in front of it, \@, to make sure it is treated just as a character.



    Python Regular Expressions

    Regular expressions are a powerful language for matching text patterns. This page gives a basic introduction to regular expressions themselves sufficient for our Python exercises and shows how regular expressions work in Python. The Python "re" module provides regular expression support.
    In Python a regular expression search is typically written as:

      match = re.search(pat, str)
    The re.search() method takes a regular expression pattern and a string and searches for that pattern within the string. If the search is successful, search() returns a match object or None otherwise. Therefore, the search is usually immediately followed by an if-statement to test if the search succeeded, as shown in the following example which searches for the pattern 'word:' followed by a 3 letter word (details below):

    str = 'an example word:cat!!'
    match = re.search(r'word:\w\w\w', str)
    # If-statement after search() tests if it succeeded
      if match:
        print 'found', match.group() ## 'found word:cat'
      else:
        print 'did not find'
    The code match = re.search(pat, str) stores the search result in a variable named "match". Then the if-statement tests the match -- if true the search succeeded and match.group() is the matching text (e.g. 'word:cat'). Otherwise if the match is false (None to be more specific), then the search did not succeed, and there is no matching text.

    The 'r' at the start of the pattern string designates a python "raw" string which passes through backslashes without change which is very handy for regular expressions (Java needs this feature badly!). I recommend that you always write pattern strings with the 'r' just as a habit.

    Basic Patterns

    The power of regular expressions is that they can specify patterns, not just fixed characters. Here are the most basic patterns which match single chars:

    a, X, 9, < -- ordinary characters just match themselves exactly. The meta-characters which do not match themselves because they have special meanings are: . ^ $ * + ? { [ ] \ | ( ) (details below)
    . (a period) -- matches any single character except newline '\n'
    \w -- (lowercase w) matches a "word" character: a letter or digit or underbar [a-zA-Z0-9_]. Note that although "word" is the mnemonic for this, it only matches a single word char, not a whole word. \W (upper case W) matches any non-word character.
    \b -- boundary between word and non-word
    \s -- (lowercase s) matches a single whitespace character -- space, newline, return, tab, form [ \n\r\t\f]. \S (upper case S) matches any non-whitespace character.
    \t, \n, \r -- tab, newline, return
    \d -- decimal digit [0-9] (some older regex utilities do not support but \d, but they all support \w and \s)
    ^ = start, $ = end -- match the start or end of the string
    \ -- inhibit the "specialness" of a character. So, for example, use \. to match a period or \\ to match a slash. If you are unsure if a character has special meaning, such as '@', you can put a slash in front of it, \@, to make sure it is treated just as a character.





    Basic Examples

    Joke: what do you call a pig with three eyes? piiig!

    The basic rules of regular expression search for a pattern within a string are:

    The search proceeds through the string from start to end, stopping at the first match found
    All of the pattern must be matched, but not all of the string
    If match = re.search(pat, str) is successful, match is not None and in particular match.group() is the matching text
      ## Search for pattern 'iii' in string 'piiig'.
      ## All of the pattern must match, but it may appear anywhere.
      ## On success, match.group() is matched text.
      match = re.search(r'iii', 'piiig') =>  found, match.group() == "iii"
      match = re.search(r'igs', 'piiig') =>  not found, match == None

      ## . = any char but \n
      match = re.search(r'..g', 'piiig') =>  found, match.group() == "iig"

      ## \d = digit char, \w = word char
      match = re.search(r'\d\d\d', 'p123g') =>  found, match.group() == "123"
      match = re.search(r'\w\w\w', '@@abcd!!') =>  found, match.group() == "abc"



Repetition

Things get more interesting when you use + and * to specify repetition in the pattern

+ -- 1 or more occurrences of the pattern to its left, e.g. 'i+' = one or more i's
* -- 0 or more occurrences of the pattern to its left
? -- match 0 or 1 occurrences of the pattern to its left




Leftmost & Largest

First the search finds the leftmost match for the pattern, and second it tries to use up as much of the string as possible -- i.e. + and * go as far as possible (the + and * are said to be "greedy").




Repetition Examples

  ## i+ = one or more i's, as many as possible.
  match = re.search(r'pi+', 'piiig') =>  found, match.group() == "piii"

  ## Finds the first/leftmost solution, and within it drives the +
  ## as far as possible (aka 'leftmost and largest').
  ## In this example, note that it does not get to the second set of i's.
  match = re.search(r'i+', 'piigiiii') =>  found, match.group() == "ii"

  ## \s* = zero or more whitespace chars
  ## Here look for 3 digits, possibly separated by whitespace.
  match = re.search(r'\d\s*\d\s*\d', 'xx1 2   3xx') =>  found, match.group() == "1 2   3"
  match = re.search(r'\d\s*\d\s*\d', 'xx12  3xx') =>  found, match.group() == "12  3"
  match = re.search(r'\d\s*\d\s*\d', 'xx123xx') =>  found, match.group() == "123"

  ## ^ = matches the start of string, so this fails:
  match = re.search(r'^b\w+', 'foobar') =>  not found, match == None
  ## but without the ^ it succeeds:
  match = re.search(r'b\w+', 'foobar') =>  found, match.group() == "bar"




  Emails Example

  Suppose you want to find the email address inside the string 'xyz alice-b@google.com purple monkey'. We'll use this as a running example to demonstrate more regular expression features. Here's an attempt using the pattern r'\w+@\w+':

    str = 'purple alice-b@google.com monkey dishwasher'
    match = re.search(r'\w+@\w+', str)
    if match:
      print match.group()  ## 'b@google'
  The search does not get the whole email address in this case because the \w does not match the '-' or '.' in the address. We'll fix this using the regular expression features below.




  Square Brackets

  Square brackets can be used to indicate a set of chars, so [abc] matches 'a' or 'b' or 'c'. The codes \w, \s etc. work inside square brackets too with the one exception that dot (.) just means a literal dot. For the emails problem, the square brackets are an easy way to add '.' and '-' to the set of chars which can appear around the @ with the pattern r'[\w.-]+@[\w.-]+' to get the whole email address:

    match = re.search(r'[\w.-]+@[\w.-]+', str)
    if match:
      print match.group()  ## 'alice-b@google.com'
  (More square-bracket features) You can also use a dash to indicate a range, so [a-z] matches all lowercase letters. To use a dash without indicating a range, put the dash last, e.g. [abc-]. An up-hat (^) at the start of a square-bracket set inverts it, so [^ab] means any char except 'a' or 'b'.
